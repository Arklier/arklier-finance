-- Exchange and Transaction Schema Migration
-- This migration creates the core tables for handling cryptocurrency exchange data

-- 1) Where users store API credentials (encrypted) for Firi
create table if not exists exchange_connections (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  exchange text not null check (exchange in ('firi')),
  label text default 'Firi',
  -- store client-provided identifiers
  api_key text not null,
  client_id text not null,
  -- encrypted secret at rest (pgcrypto); store iv/salt alongside if you prefer
  api_secret bytea not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (user_id, exchange)
);

-- 2) Raw ingest (immutable append-only)
create table if not exists raw_transactions (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  connection_id uuid not null references exchange_connections(id) on delete cascade,
  provider text not null, -- 'firi'
  provider_tx_id text,    -- e.g., firi 'id' field or order id
  kind text,              -- e.g., 'history.transaction', 'deposit', 'order'
  occurred_at timestamptz,
  payload jsonb not null,
  ingested_at timestamptz not null default now(),
  unique (connection_id, provider, provider_tx_id, kind)
);

-- 3) Normalized view for your app logic
-- canonical transaction types from your earlier spec
create type txn_type as enum ('buy','sell','deposit','withdrawal','send','transfer','staking','bonus','fee','rebate','trade_match');

create table if not exists normalized_transactions (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  connection_id uuid not null references exchange_connections(id) on delete cascade,
  source_raw_id bigint not null references raw_transactions(id) on delete cascade,
  txn_type txn_type not null,
  -- unified asset/amount fields (handles both "match" and single-row styles)
  base_asset text,         -- e.g., BTC in BTC/NOK trade
  base_amount numeric,     -- signed; positive in, negative out (from the user's perspective)
  quote_asset text,        -- e.g., NOK
  quote_amount numeric,    -- signed
  fee_asset text,
  fee_amount numeric,
  price numeric,           -- when applicable (quote/base)
  txid text,               -- on-chain where present
  order_id text,           -- exchange order id where present
  occurred_at timestamptz not null,
  metadata jsonb default '{}'::jsonb
);

-- 4) Helpful indexes
create index if not exists idx_raw_user_time on raw_transactions(user_id, occurred_at);
create index if not exists idx_norm_user_time on normalized_transactions(user_id, occurred_at);

-- 5) RLS
alter table exchange_connections enable row level security;
alter table raw_transactions enable row level security;
alter table normalized_transactions enable row level security;

create policy "users can manage their connections"
on exchange_connections for all
using (auth.uid() = user_id) with check (auth.uid() = user_id);

create policy "users read own raw tx"
on raw_transactions for select
using (auth.uid() = user_id);

create policy "users read own normalized tx"
on normalized_transactions for select
using (auth.uid() = user_id);

-- inserts via server routines (Edge/Vercel functions) will use service key
